/**
 * Cloudflare for SaaS Integration
 * 
 * This service handles custom hostname management using Cloudflare for SaaS.
 * It allows users to connect their own domains to their Shipper projects.
 * 
 * @see https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/
 */

interface CloudflareConfig {
  apiToken: string;
  zoneId: string;
  accountId: string;
}

interface CustomHostname {
  id: string;
  hostname: string; // The user's custom domain (e.g., "example.com")
  ssl: {
    status: string;
    method: string;
    type: string;
    validation_errors?: Array<{
      message: string;
    }>;
    validation_records?: Array<{
      status: string;
      txt_name?: string;
      txt_value?: string;
      http_url?: string;
      http_body?: string;
    }>;
    cname_target?: string; // The Cloudflare CDN hostname to point to
    cname?: string; // Alternative field name for CNAME target
  };
  status: string;
  verification_errors?: string[];
  ownership_verification?: {
    type: string;
    name: string;
    value: string;
  };
  ownership_verification_http?: {
    http_url: string;
    http_body: string;
  };
  created_at: string;
  custom_metadata?: Record<string, string>;
}

interface CloudflareResponse<T> {
  success: boolean;
  errors: Array<{ code: number; message: string }>;
  messages: string[];
  result: T;
}

export class CloudflareSaaSService {
  private config: CloudflareConfig;
  private baseUrl = 'https://api.cloudflare.com/client/v4';

  constructor(config: CloudflareConfig) {
    this.config = config;
  }

  /**
   * Create a custom hostname in Cloudflare
   * Note: custom_metadata is removed as it requires Enterprise plan
   */
  async createCustomHostname(
    domain: string,
    _projectId: string,
  ): Promise<CustomHostname> {
    const url = `${this.baseUrl}/zones/${this.config.zoneId}/custom_hostnames`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        hostname: domain,
        ssl: {
          method: 'http', // HTTP validation (easier for users - no SSL TXT record needed)
          type: 'dv', // Domain Validation
          settings: {
            http2: 'on',
            min_tls_version: '1.2',
            tls_1_3: 'on',
          },
        },
        // Note: ownership_verification TXT record is ALWAYS generated by Cloudflare
        // regardless of SSL method - this proves domain ownership
        // custom_metadata removed - requires Enterprise plan
        // We'll track project_id in our database instead
      }),
    });

    const data = await response.json() as CloudflareResponse<CustomHostname>;

    if (!data.success) {
      const errorMessage = data.errors.map(e => e.message).join(', ');
      throw new Error(`Cloudflare API error: ${errorMessage}`);
    }

    return data.result;
  }

  /**
   * Get custom hostname details
   */
  async getCustomHostname(hostnameId: string): Promise<CustomHostname> {
    const url = `${this.baseUrl}/zones/${this.config.zoneId}/custom_hostnames/${hostnameId}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
        'Content-Type': 'application/json',
      },
    });

    const data = await response.json() as CloudflareResponse<CustomHostname>;

    if (!data.success) {
      const errorMessage = data.errors.map(e => e.message).join(', ');
      throw new Error(`Cloudflare API error: ${errorMessage}`);
    }

    return data.result;
  }

  /**
   * Delete a custom hostname
   */
  async deleteCustomHostname(hostnameId: string): Promise<void> {
    const url = `${this.baseUrl}/zones/${this.config.zoneId}/custom_hostnames/${hostnameId}`;

    console.log(`[CloudflareSaaS] Attempting to delete hostname: ${hostnameId}`);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

    try {
      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
          'Content-Type': 'application/json',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      console.log(`[CloudflareSaaS] Delete response status: ${response.status}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CloudflareSaaS] HTTP error ${response.status}: ${errorText}`);
        throw new Error(`Cloudflare HTTP error ${response.status}: ${errorText}`);
      }

      let data: CloudflareResponse<{ id: string }>;
      try {
        data = await response.json() as CloudflareResponse<{ id: string }>;
      } catch (jsonError) {
        const responseText = await response.text();
        console.error(`[CloudflareSaaS] Invalid JSON response: ${responseText}`);
        throw new Error(`Cloudflare returned invalid JSON: ${responseText}`);
      }

      if (!data.success) {
        const errorMessage = data.errors?.map(e => e.message).join(', ') || 'Unknown error';
        console.error(`[CloudflareSaaS] API error: ${errorMessage}`, data.errors);
        throw new Error(`Cloudflare API error: ${errorMessage}`);
      }

      console.log(`[CloudflareSaaS] Successfully deleted hostname: ${hostnameId}`);
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error && error.name === 'AbortError') {
        console.error(`[CloudflareSaaS] Delete timeout for hostname: ${hostnameId}`);
        throw new Error(`Cloudflare delete timeout after 30 seconds for hostname: ${hostnameId}`);
      }

      console.error(`[CloudflareSaaS] Delete failed for hostname ${hostnameId}:`, error);
      throw error; // Re-throw to ensure it's not silently ignored
    }
  }

  /**
   * List all custom hostnames for the zone
   */
  async listCustomHostnames(): Promise<CustomHostname[]> {
    const url = `${this.baseUrl}/zones/${this.config.zoneId}/custom_hostnames`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
        'Content-Type': 'application/json',
      },
    });

    const data = await response.json() as CloudflareResponse<CustomHostname[]>;

    if (!data.success) {
      const errorMessage = data.errors.map(e => e.message).join(', ');
      throw new Error(`Cloudflare API error: ${errorMessage}`);
    }

    return data.result;
  }

  /**
   * Extract the CNAME target from Cloudflare response
   * This is the hostname users should point their DNS to
   * 
   * For Cloudflare for SaaS, users must CNAME to the fallback origin
   * (e.g., cname.shipper.now), NOT to the .cdn.cloudflare.net hostname
   */
  static getCnameTarget(_cfHostname: CustomHostname): string {
    // Always return the fallback origin from environment
    // This is what users should point their DNS to
    const fallbackOrigin = process.env.CLOUDFLARE_FALLBACK_ORIGIN || 'cname.shipper.now';
    return fallbackOrigin;
  }

  /**
   * Check if domain is valid format
   */
  static isValidDomain(domain: string): boolean {
    // Basic domain validation
    const domainRegex = /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$/i;
    return domainRegex.test(domain);
  }

  /**
   * Map Cloudflare status to our domain status
   */
  static mapCloudflareStatus(cfStatus: string): 'PENDING_VALIDATION' | 'ACTIVE' | 'FAILED' {
    switch (cfStatus) {
      case 'active':
        return 'ACTIVE';
      case 'pending':
      case 'pending_validation':
        return 'PENDING_VALIDATION';
      case 'blocked':
      case 'deleted':
        return 'FAILED';
      default:
        return 'PENDING_VALIDATION';
    }
  }

  /**
   * Map Cloudflare SSL status to our SSL status
   */
  static mapSSLStatus(sslStatus: string): 'PENDING' | 'ACTIVE' | 'FAILED' {
    switch (sslStatus) {
      case 'active':
        return 'ACTIVE';
      case 'pending_validation':
      case 'pending_issuance':
      case 'pending_deployment':
        return 'PENDING';
      case 'failed':
        return 'FAILED';
      default:
        return 'PENDING';
    }
  }
}

/**
 * Create a CloudflareSaaSService instance with environment variables
 */
export function createCloudflareService(): CloudflareSaaSService {
  const apiToken = process.env.CLOUDFLARE_API_TOKEN;
  const zoneId = process.env.CLOUDFLARE_ZONE_ID;
  const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;

  if (!apiToken || !zoneId || !accountId) {
    const missing = [];
    if (!apiToken) missing.push('CLOUDFLARE_API_TOKEN');
    if (!zoneId) missing.push('CLOUDFLARE_ZONE_ID');
    if (!accountId) missing.push('CLOUDFLARE_ACCOUNT_ID');
    
    throw new Error(
      `Missing Cloudflare configuration: ${missing.join(', ')}. Please set these environment variables and restart the API server.`
    );
  }

  console.log('[Cloudflare] Service initialized with zone:', zoneId);

  return new CloudflareSaaSService({
    apiToken,
    zoneId,
    accountId,
  });
}
